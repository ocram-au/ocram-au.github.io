import{hS as f,hT as y,hU as U,hV as b,bo as h,cY as g,cU as R,hW as v,hX as C,hY as W,hZ as j,du as k,h_ as x,h$ as A}from"./index-D5ClABWK.js";import{geodesicArea as F}from"./geometryEngine-C1PWFfKx.js";import{p as M,y as S}from"./geodesicLengthMeasurementUtils-Bes3doSI.js";function E(n){const{spatialReference:e}=n;return M(e,Y,Z,n)}function Y(n){return f(Math.abs(S([n],"square-meters")[0]),"square-meters")}function Z(n){try{return f(Math.abs(F(n,"square-meters")),"square-meters")}catch{return null}}function G(n,e=V()){return w(n,e,!1)}function w(n,e,o=n.hasZ){const a=U(n.spatialReference),u=b(a);if(u==null)return null;const d=(c,s)=>!(s.length<2)&&(g(c,s[0],s[1],o&&s[2]||0),!0);let p=0;for(const c of n.rings){const s=c.length;if(s<3)continue;const{positionsWorldCoords:r}=e;for(;r.length<s;)r.push(h());const $=K,i=g(T,0,0,0),q=1/s;for(let t=0;t<s;t++){if(!d($,c[t])||!R($,n.spatialReference,r[t],a))return null;v(i,i,r[t],q)}const m=C(r[0],r[1],i,W());if(j(k(m))===0)continue;for(let t=0;t<s;t++)x(m,i,r[t],r[t]);const l=X(r);for(let t=0;t<l.length;t+=3)p+=A(r[l[t]],r[l[t+1]],r[l[t+2]])}return f(p,u)}const K=h(),T=h();function V(){return{positionsWorldCoords:[]}}function X(n){return y(_(n),[],2)}function _(n){const e=new Float64Array(2*n.length);for(let o=0;o<n.length;++o){const a=n[o],u=2*o;e[u]=a[0],e[u+1]=a[1]}return e}export{V as U,G as j,X as k,E as o};
