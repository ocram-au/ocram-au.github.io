import{g5 as k,dn as U,c1 as D,ar as W,as as E,i4 as j,at as T,nU as _,e4 as q,g as H,eh as F,nV as V,dk as X,nW as I,nX as S,k as N,hT as Q,nY as Z,nZ as A,n_ as Y,n$ as B,o0 as J,o1 as z,r as l,m as u,a as K}from"./index-BGUxYM9l.js";const ee=50,te=5;function re(e,n){return Math.log(e)/Math.log(n)}function ne(e,n,r){const t=e===1?10:e;return t**(r?Math.round(re(ee/n,t)):0)}function ie(e){const{isGeographic:n,isWebMercator:r}=e;return!n&&!r}function se(e,n,r){const t=typeof e=="number"?null:e,i=r??(t==null?void 0:t.spatialReference);if(i==null||!k(i)||ie(i))return U(i);let s=(t==null?void 0:t.x)??e,a=(t==null?void 0:t.y)??n;const p=1/Math.sqrt(2);let d=s+p,f=a+p;const{isWebMercator:h,isGeographic:R}=i;let w=R&&!D(i)?W.WGS84:i;if(h){let c=new E({x:s,y:a,spatialReference:i});j(c,!0,c),s=c.x,a=c.y,c=new E({x:d,y:f,spatialReference:i}),j(c,!0,c),d=c.x,f=c.y,w=W.WGS84}const M=new T({paths:[[[s,a],[d,f]]],spatialReference:w}),$=_(M,10);let g;try{[g]=q([$],"meters")}catch{return U(i)}return g}let o=class extends H{constructor(e){super(e),this.options=null}destroy(){this._set("options",null)}get grid(){return this.view.grid}get effectiveViewRotation(){var e;return(e=this.grid)!=null&&e.rotateWithMap?0:F(this.view.rotation??0)}get gridRotation(){var e;return F(((e=this.grid)==null?void 0:e.rotation)??0)}get gridCenter(){var r;const{spatialReference:e,grid:n}=this;if(!n||!e||!V(n.center.spatialReference,e))return null;try{const t=X(n.center,e),i=e.isWrappable&&((r=this.view)==null?void 0:r.center)!=null?I(t.x,this.view.center.x,e):t.x;return S(i,t.y,t.z)}catch(t){return N.getLogger(this).errorOnce("Grid Snapping - Failed to project grid center.",t),null}}get offsetScaleFactor(){const{pixelsPerStride:e,grid:n}=this;if(!n||!e)return 1;const{majorLineInterval:r,dynamicScaling:t}=n;return r<1?null:ne(r,e,t)}get spatialReference(){return this.view.spatialReference}get gridMetersPerStride(){const{grid:e}=this;return e?Q(e.spacing,e.units,"meters"):null}get viewMetersPerPixel(){const{viewMetersPerSRUnit:e}=this;return e==null?null:e*Z(this.view.scale,this.view.spatialReference)}get viewMetersPerSRUnit(){const{spatialReference:e}=this.view;return this.gridCenter?se(this.gridCenter[0],this.gridCenter[1],e):null}get pixelsPerStride(){const{gridMetersPerStride:e,viewMetersPerPixel:n}=this;return n&&e?e/n:null}get updating(){return this.grid!=null&&this.spatialReference!=null&&this.viewMetersPerSRUnit==null}async fetchCandidates(e,n,r){var p;const{options:t,view:i}=this;if(!(t!=null&&t.effectiveGridEnabled)||!i.grid||(p=r.feature)!=null&&p.attributes&&A in r.feature.attributes)return[];const s=r.coordinateHelper.arrayToPoint(e),a=t.distance*(r.pointer==="touch"?t.touchSensitivityMultiplier:1);return this.fetchCandidatesSync(s,a)}fetchCandidatesSync(e,n){const r=[],{grid:t,effectiveViewRotation:i,gridRotation:s,gridCenter:a,viewMetersPerPixel:p,viewMetersPerSRUnit:d,offsetScaleFactor:f,spatialReference:h,gridMetersPerStride:R,pixelsPerStride:w}=this;if(!(t&&p&&d&&a&&h&&f&&R&&w)||!t.dynamicScaling&&w<te||!V(e.spatialReference,h))return r;const M=X(e,h),$=S(M.x,M.y,M.z),g=v($,-s,a,-i),c=R/d*f,y=ae(g,c,a),{shouldSnapX:P,shouldSnapY:x}=oe(y,g,n,p,d);if(!P&&!x)return[];const O=S((P?y:g)[0],(x?y:g)[1]),b=v(O,s,a,i),G=v(y,s,a,i);if(x){const m=L(y,g,c,"y"),C=v(m,s,a,i);r.push(new Y({lineStart:G,lineEnd:C,targetPoint:b,isDraped:!1}))}if(P){const m=L(y,g,c,"x"),C=v(m,s,a,i);r.push(new Y({lineStart:G,lineEnd:C,targetPoint:b,isDraped:!1}))}return P&&x&&r.push(new B(b,r[0],r[1],!1)),r}};l([u({constructOnly:!0})],o.prototype,"view",void 0),l([u()],o.prototype,"options",void 0),l([u()],o.prototype,"grid",null),l([u()],o.prototype,"effectiveViewRotation",null),l([u()],o.prototype,"gridRotation",null),l([u()],o.prototype,"gridCenter",null),l([u()],o.prototype,"offsetScaleFactor",null),l([u()],o.prototype,"spatialReference",null),l([u()],o.prototype,"gridMetersPerStride",null),l([u()],o.prototype,"viewMetersPerPixel",null),l([u()],o.prototype,"viewMetersPerSRUnit",null),l([u()],o.prototype,"pixelsPerStride",null),l([u()],o.prototype,"updating",null),o=l([K("esri.views.interactive.snapping.GridSnappingEngine")],o);const v=(e,n,r,t)=>{const i=J(e[0],e[1],e[2]);return z(i,z(i,i,r,n),r,t)},ae=(e,n,r)=>{const t=(e[0]-r[0])/n,i=(e[1]-r[1])/n,s=Math.trunc(t),a=Math.trunc(i),p=Math.round(t%1),d=Math.round(i%1),f=r[0]+(s+p)*n,h=r[1]+(a+d)*n;return S(f,h)},oe=(e,n,r,t,i)=>{if(t<=0)return{shouldSnapX:!1,shouldSnapY:!1};const s=(e[0]-n[0])/t,a=(e[1]-n[1])/t;return{shouldSnapX:Math.abs(s*i)<r,shouldSnapY:Math.abs(a*i)<r}},L=(e,n,r,t)=>{if(t==="y"){const s=n[0]>e[0]?1:-1;return S(e[0]+r*s,e[1])}const i=n[1]>e[1]?1:-1;return S(e[0],e[1]+r*i)};export{o as GridSnappingEngine};
