import{lQ as v,cs as K,aB as ft,fF as X,lR as pt,k as I,c9 as st,ay as dt,j as Mt,lS as mt,lT as gt,e9 as $t,bo as Z,dr as yt,cG as Rt,k9 as wt,dq as vt,lU as zt,ka as at,cm as jt,lV as B}from"./index-CQXxPdCL.js";import{geodesicLength as rt}from"./geometryEngine-BhPwz75N.js";function it(t){if(!t)return null;if(X(t)&&t.wkid){const n=pt[t.wkid];if(n)return n}const e=t.wkt2||t.wkt;if(e){const n=qt(e);if(n)return n}return null}function qt(t){const e=mt.exec(t);if(!e||e.length!==2)return null;const n=e[1].split(",");if(!n||n.length<3)return null;const s=parseFloat(n[1]),a=parseFloat(n[2]);return isNaN(s)||isNaN(a)?null:{a:s,f:a===0?0:1/a}}function H(t){const e=it(t);if(bt(e))return e;const n=e.a*(1-e.f);return Object.assign(e,{b:n,eSq:1-(n/e.a)**2,radius:(2*e.a+n)/3,densificationRatio:1e4/((2*e.a+n)/3)})}function bt(t){return t!=null&&"b"in t&&"eSq"in t&&"radius"in t}function P(t,e,n){const{a:s,eSq:a}=H(n),r=Math.sqrt(a),c=Math.sin(e[1]*v),i=s*e[0]*v;let l;return a>0?l=s*((1-a)*(c/(1-a*(c*c))-1/(2*r)*Math.log((1-r*c)/(1+r*c))))*.5:l=s*c,t[0]=i,t[1]=l,t}function G(t){return it(t)!==null}function Et(t,e="square-meters"){if(t.some(c=>!G(c.spatialReference)))throw new I("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let c=0;c<t.length;c++){const i=t[c],l=i.spatialReference,{radius:u,densificationRatio:h}=H(l),o=u*h;n.push(kt(i,o))}const s=[],a=[0,0],r=[0,0];for(let c=0;c<n.length;c++){const{rings:i,spatialReference:l}=n[c];let u=0;for(let h=0;h<i.length;h++){const o=i[h];P(a,o[0],l),P(r,o[o.length-1],l);let d=r[0]*a[1]-a[0]*r[1];for(let M=0;M<o.length-1;M++)P(a,o[M+1],l),P(r,o[M],l),d+=r[0]*a[1]-a[0]*r[1];u+=d}u=st(u,"square-meters",e),s.push(u/-2)}return s}function St(t,e="meters"){if(!t)throw new I("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(t.some(s=>!G(s.spatialReference)))throw new I("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let s=0;s<t.length;s++){const a=t[s],{spatialReference:r}=a,c=a.type==="polyline"?a.paths:a.rings;let i=0;for(let l=0;l<c.length;l++){const u=c[l];let h=0;for(let o=1;o<u.length;o++){const d=u[o-1][0],M=u[o][0],y=u[o-1][1],m=u[o][1];if(y!==m||d!==M){const p=new Y;_(p,[d,y],[M,m],r),h+=p.distance}}i+=h}i=st(i,"meters",e),n.push(i)}return n}function kt(t,e){if(t.type!=="polyline"&&t.type!=="polygon")throw new I("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=t;if(!G(n))throw new I("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const s=t.type==="polyline"?t.paths:t.rings,a=[],r=[0,0],c=new Y;for(const i of s){const l=[];a.push(l),l.push([i[0][0],i[0][1]]);let u,h,o=i[0][0],d=i[0][1];for(let M=0;M<i.length-1;M++){if(u=i[M+1][0],h=i[M+1][1],o===u&&d===h)continue;const y=[o,d];_(c,[o,d],[u,h],n);const{azimuth:m,distance:p}=c,R=p/e;if(R>1){for(let g=1;g<=R-1;g++)W(r,y,m,g*e,n),l.push(r.slice(0));W(r,y,m,(p+Math.floor(R-1)*e)/2,n),l.push(r.slice(0))}W(r,y,m,p,n),l.push(r.slice(0)),o=r[0],d=r[1]}}return t.type==="polyline"?new dt({paths:a,spatialReference:n}):new Mt({rings:a,spatialReference:n})}class Y{constructor(e=0,n=void 0,s=void 0){this.distance=e,this.azimuth=n,this.reverseAzimuth=s}}function W(t,e,n,s,a){const r=e[0],c=e[1],i=r*v,l=c*v,u=(n??0)*v,{a:h,b:o,f:d}=H(a),M=Math.sin(u),y=Math.cos(u),m=(1-d)*Math.tan(l),p=1/Math.sqrt(1+m*m),R=m*p,g=Math.atan2(m,y),F=p*M,k=F*F,z=1-k,f=z*(h*h-o*o)/(o*o),x=1+f/16384*(4096+f*(f*(320-175*f)-768)),A=f/1024*(256+f*(f*(74-47*f)-128));let w,q,$,N,S=s/(o*x),j=2*Math.PI;for(;Math.abs(S-j)>1e-12;)$=Math.cos(2*g+S),w=Math.sin(S),q=Math.cos(S),N=A*w*($+A/4*(q*(2*$*$-1)-A/6*$*(4*w*w-3)*(4*$*$-3))),j=S,S=s/(o*x)+N;const b=R*w-p*q*y,C=Math.atan2(R*q+p*w*y,(1-d)*Math.sqrt(k+b*b)),L=Math.atan2(w*M,p*q-R*w*y),T=d/16*z*(4+d*(4-3*z)),Q=C/v,V=(i+(L-(1-T)*d*F*(S+T*w*($+T*q*(2*$*$-1)))))/v;return t[0]=V,t[1]=Q,t}function _(t,e,n,s){const a=e[0]*v,r=e[1]*v,c=n[0]*v,i=n[1]*v,{a:l,b:u,f:h,radius:o}=H(s),d=c-a,M=Math.atan((1-h)*Math.tan(r)),y=Math.atan((1-h)*Math.tan(i)),m=Math.sin(M),p=Math.cos(M),R=Math.sin(y),g=Math.cos(y);let F,k,z,f,x,A,w,q,$,N,S=1e3,j=d;do{if(w=Math.sin(j),q=Math.cos(j),z=Math.sqrt(g*w*(g*w)+(p*R-m*g*q)*(p*R-m*g*q)),z===0)return t.distance=0,t.azimuth=void 0,t.reverseAzimuth=void 0,t;x=m*R+p*g*q,A=Math.atan2(z,x),$=p*g*w/z,k=1-$*$,f=x-2*m*R/k,isNaN(f)&&(f=0),N=h/16*k*(4+h*(4-3*k)),F=j,j=d+(1-N)*h*$*(A+N*z*(f+N*x*(2*f*f-1)))}while(Math.abs(j-F)>1e-12&&--S>0);if(S===0){const V=o,ct=Math.acos(Math.sin(r)*Math.sin(i)+Math.cos(r)*Math.cos(i)*Math.cos(c-a))*V,tt=c-a,lt=Math.sin(tt)*Math.cos(i),ut=Math.cos(r)*Math.sin(i)-Math.sin(r)*Math.cos(i)*Math.cos(tt),ht=Math.atan2(lt,ut);return t.azimuth=ht/v,t.distance=ct,t.reverseAzimuth=void 0,t}const b=k*(l*l-u*u)/(u*u),C=b/1024*(256+b*(b*(74-47*b)-128)),L=u*(1+b/16384*(4096+b*(b*(320-175*b)-768)))*(A-C*z*(f+C/4*(x*(2*f*f-1)-C/6*f*(4*z*z-3)*(4*f*f-3)))),T=Math.atan2(g*Math.sin(j),p*R-m*g*Math.cos(j)),Q=Math.atan2(p*Math.sin(j),p*R*Math.cos(j)-m*g);return t.azimuth=T/v,t.distance=L,t.reverseAzimuth=Q/v,t}function Ot(t){return G(t)?t:K(t)?ft.WGS84:null}function Zt(t,e,n,s){n.projectToRenderScreen(t,et),n.projectToRenderScreen(e,nt),Rt(s,nt,et),wt(s,s)}function xt(t,e,n,s,a=Z()){const r=vt(J,t);return r[2]=zt(s,r,e,n)||0,s.renderCoordsHelper.toRenderCoords(r,e,a),a}function Bt(t,e,n,s){return s.type==="2d"?(U.x=t[0],U.y=t[1],U.spatialReference=e,s.toScreen(U)):(xt(t,e,n,s,J),s.state.camera.projectToScreen(J,D),gt(D[0],D[1]))}const U=$t(0,0,0,null),J=Z(),et=at(),nt=at(),D=yt();function Ht(t){return X(t)&&G(t)||K(t)}function ot(t,e,n,...s){return X(t)&&G(t)?e.apply(void 0,s):K(t)?n.apply(void 0,s):null}const Lt=1e5;function Qt(t){const{spatialReference:e}=t;return ot(e,Gt,Ct,t)}function Vt(t,e){if(!jt(t.spatialReference,e.spatialReference))return null;const{spatialReference:n}=t;return E[0]=t.x,E[1]=t.y,E[2]=t.hasZ?t.z:0,O[0]=e.x,O[1]=e.y,O[2]=e.hasZ?e.z:0,At(E,O,n)}function At(t,e,n){return ot(n,Nt,Ft,t,e,n)}function Nt(t,e,n){return B(_(It,t,e,n).distance,"meters")}function Ft(t,e,n){return B(rt(Tt(t,e,n),"meters"),"meters")}function Gt(t){return B(St([t],"meters")[0],"meters")}function Ct(t){return B(rt(t,"meters"),"meters")}function Tt(t,e,n){return{type:"polyline",spatialReference:n,paths:[[[...t],[...e]]]}}const It=new Y,E=Z(),O=Z();export{Ot as A,Zt as a,W as b,Bt as d,Vt as f,Lt as i,_ as j,xt as l,Qt as m,ot as p,Ht as r,At as u,Et as y,Y as z};
