import{i8 as f,i9 as b,ia as y,ib as R,bk as h,c$ as g,cX as k,ic as v,id as x,ie as C,ig as U,dx as j,ih as A,ii as F}from"./index-31kweLEy.js";import{geodesicArea as M}from"./geometryEngine-6tQWe8kk.js";import{p as W,y as w}from"./geodesicLengthMeasurementUtils-x2MobWlA.js";function J(n){const{spatialReference:r}=n;return W(r,K,S,n)}function K(n){return f(Math.abs(w([n],"square-meters")[0]),"square-meters")}function S(n){try{return f(Math.abs(M(n,"square-meters")),"square-meters")}catch{return null}}function L(n,r=B()){return X(n,r,!1)}function X(n,r,o=n.hasZ){const i=y(n.spatialReference),a=R(i);if(a==null)return null;const d=(u,s)=>!(s.length<2)&&(g(u,s[0],s[1],o&&s[2]||0),!0);let p=0;for(const u of n.rings){const s=u.length;if(s<3)continue;const{positionsWorldCoords:e}=r;for(;e.length<s;)e.push(h());const $=Z,c=g(z,0,0,0),q=1/s;for(let t=0;t<s;t++){if(!d($,u[t])||!k($,n.spatialReference,e[t],i))return null;v(c,c,e[t],q)}const m=x(e[0],e[1],c,C());if(U(j(m))===0)continue;for(let t=0;t<s;t++)A(m,c,e[t],e[t]);const l=D(e);for(let t=0;t<l.length;t+=3)p+=F(e[l[t]],e[l[t+1]],e[l[t+2]])}return f(p,a)}const Z=h(),z=h();function B(){return{positionsWorldCoords:[]}}function D(n){return b(E(n),[],2)}function E(n){const r=new Float64Array(2*n.length);for(let o=0;o<n.length;++o){const i=n[o],a=2*o;r[a]=i[0],r[a+1]=i[1]}return r}export{B as U,L as j,D as k,J as o};
