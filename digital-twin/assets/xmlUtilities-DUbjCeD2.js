const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/geometryEngine-DEWZpdAD.js","assets/index-BGUxYM9l.js","assets/index-C0kMKE5c.css","assets/geometryEngineBase-B0ZyeKAX.js","assets/_commonjsHelpers-DCkdB7M8.js","assets/hydrated-Du69Np28.js"])))=>i.map(i=>d[i]);
import{cR as Ce,ct as Z,rZ as Re,k as ie,aq as be,as as E,aN as U,F as j,N as Ie,gP as Je,ar as we,ce as Be,r_ as He,r as x,m as R,cs as _e,a as ae,hS as ze,_ as De,j as $e,hG as Ne,cS as Me,cq as Oe,d4 as Ee}from"./index-BGUxYM9l.js";import{g as Se,N as We,i as Le,a as Ge,b as ve,c as qe,w as le,p as Ae,l as je,d as Ve,e as Ue,f as Qe,h as ce,j as ue,W as he,k as Xe,v as Ze,m as Ke,t as Ye,z as et,L as tt,U as it,E as nt,q as de}from"./ImageHistogramParameters-C5a_RcmY.js";import{U as ee,j as rt,n as st,D as ke,R as at,u as ot,l as lt,f as ct,m as ut,s as ht,_ as dt,a as ft}from"./dataUtils-kR_WxIZM.js";import{QueueProcessor as mt}from"./QueueProcessor-BHGYgVLN.js";import{t as Q,j as ne,B as fe,m as me,u as pt,o as te,V as X,a as yt,r as gt,z as xt,Z as re}from"./rasterProjectionHelper-sWDWnxk3.js";import{h as se,l as Rt,T as bt}from"./rasterFunctionHelper-puu4LohY.js";let It=class{constructor(t=15e3,r=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=t,this._interval=Math.min(t,r)}decreaseRefCount(t,r){const e=t+"/"+r,n=this._cachedBlocks;if(n.has(e)){const s=n.get(e);return s.refCount--,s.refCount<=0&&(n.delete(e),s.controller&&s.controller.abort()),s.refCount}return 0}getBlock(t,r){const e=t+"/"+r,n=this._cachedBlocks;if(n.has(e)){const s=n.get(e);return s.ts=Date.now(),s.refCount++,n.delete(e),n.set(e,s),s.block}return null}putBlock(t,r,e,n){const s=this._cachedBlocks,a=t+"/"+r;if(s.has(a)){const o=s.get(a);o.ts=Date.now(),o.refCount++}else s.set(a,{block:e,ts:Date.now(),refCount:1,controller:n});this._trim(),this._updateTimer()}deleteBlock(t,r){const e=this._cachedBlocks,n=t+"/"+r;e.has(n)&&e.delete(n)}updateMaxSize(t){this._size=t,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const t=this._cachedBlocks;this._timer=setInterval(()=>{const r=Array.from(t),e=Date.now();for(let n=0;n<r.length&&r[n][1].ts<=e-this._duration;n++)t.delete(r[n][0]);t.size===0&&this._clearTimer()},this._interval)}_trim(){const t=this._cachedBlocks;if(this._size===-1||this._size>=t.size)return;const r=Array.from(t);for(let e=0;e<r.length-this._size;e++)t.delete(r[e][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}};const Y=new Map,L=new It;function pe(i,t){return t==null?i:`${i}?sliceId=${t}`}function wt(i,t,r){var a,o;const e=Y.get(i);if(!e)return t==null?L.decreaseRefCount(i,r):0;if(t==null||e[t]==null)return L.decreaseRefCount(i,r);const n=(a=e[t])==null?void 0:a.cache,s=n==null?void 0:n.get(r);if(n&&s){if(s.refCount--,s.refCount===0){n.delete(r);for(let l=0;l<e.length;l++)(o=e[l])==null||o.cache.delete(r);s.controller&&s.controller.abort()}return s.refCount}return 0}function ye(i,t,r){var s,a,o;const e=Y.get(i);if(!e)return t==null?L.getBlock(i,r):null;if(t==null||e[t]==null){for(let l=0;l<e.length;l++){const c=(s=e[l])==null?void 0:s.cache.get(r);if(c)return c.refCount++,c.block}return L.getBlock(i,r)}const n=(a=e[t])==null?void 0:a.cache.get(r);if(n)return n.refCount++,n.block;for(let l=0;l<e.length;l++){if(l===t||!e[l])continue;const c=(o=e[l])==null?void 0:o.cache,u=c==null?void 0:c.get(r);if(c&&u)return u.refCount++,c.set(r,u),u.block}return null}function ge(i,t,r,e,n=null){var o;const s=Y.get(i);if(!s)return void(t==null&&L.putBlock(i,r,e,n));if(t==null||s[t]==null)return void L.putBlock(i,r,e,n);const a={refCount:1,block:e,isResolved:!1,isRejected:!1,controller:n};e.then(()=>a.isResolved=!0).catch(()=>a.isRejected=!0),(o=s[t])==null||o.cache.set(r,a)}function _t(i,t,r){var n;const e=Y.get(i);e?t!=null&&e[t]!=null?(n=e[t])==null||n.cache.delete(r):L.deleteBlock(i,r):t==null&&L.deleteBlock(i,r)}const xe=8,St=256;let vt=0,S=class extends Ce{constructor(){super(...arguments),this._tileFetchQueue=new mt({concurrency:32,process:(i,t)=>this._fetchRawTile(i.pyramidLevel,i.row,i.col,{...i.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(i){return i!=null&&i.ioConfig&&(i={...i,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:Z.create(),...i.ioConfig}}),i}get _isGlobalWrappableSource(){const{rasterInfo:i}=this,t=Q(i.spatialReference);return t!=null&&i.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:i}=this.rasterInfo;return i==null||i.type==="gcs-shift"}set rasterJobHandler(i){var t,r;this._set("rasterJobHandler",i),this.datasetFormat==="Function"&&((r=(t=this.primaryRasters)==null?void 0:t.rasters)==null||r.forEach(e=>e.rasterJobHandler=i))}get rasterId(){return this.url||"rasterId-"+vt++}set url(i){this._set("url",Re(i,ie.getLogger(this)))}async open(i){return this._openPromise??(this._openPromise=ne().then(()=>this._open(i))),this._openPromise}async fetchTile(i,t,r,e={}){const n=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(i,t,r,n);return e={noClip:!0,...e},this.fetchPixels(s,n.size[0],n.size[1],e)}async identify(i,t={}){var G;i=be(E,i).clone().normalize();const{multidimensionalDefinition:r,timeExtent:e}=t,{rasterInfo:n}=this,{hasMultidimensionalTranspose:s,multidimensionalInfo:a}=n;let{transposedVariableName:o}=t;const l=a!=null&&s&&(e!=null||Se(r));l&&!o&&(o=r!=null&&r.length>0?r[0].variableName??void 0:a.variables[0].name,t={...t,transposedVariableName:o}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:c,extent:u}=n,{datumTransformation:h}=t;let d=fe(i,c,h);if(!u.intersects(d))return{location:d,value:null};if(n.transform!=null){const B=n.transform.inverseTransform(d);if(!n.nativeExtent.intersects(B))return{location:B,value:null};d=B}let m=0;const p=o!=null&&a!=null&&n.hasMultidimensionalTranspose;if(this.datasetFormat==="Function"){const B=this.primaryRasters.rasters[0];if(p)return B.identify(d,t);const{pixelSize:q}=n,_=3,k=q.x*_/2,H=q.y*_/2,z=new U({xmin:d.x-k,xmax:d.x+k,ymin:d.y-H,ymax:d.y+H,spatialReference:c}),W={interpolation:"nearest",multidimensionalDefinition:r,sliceId:t.sliceId},{pixelBlock:T}=await B.fetchPixels(z,_,_,W),{pixelBlock:F}=await this.fetchPixels(z,_,_,W);if(T==null)return{location:d,value:null};const C=Math.floor(_*_*.5),V=!T.mask||T.mask[C]?T.pixels.map(P=>P[C]):null;let D;return F!=null&&(D=!F.mask||F.mask[C]?F.pixels.map(P=>P[C]):void 0),{location:d,value:V,processedValue:D,pyramidLevel:0}}if(!p){if(t.srcResolution)m=me(t.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(m=await this.computeBestPyramidLevelForLocation(i,t),m==null)return{location:d,value:null}}const g=this.identifyPixelLocation(d,m,null,p);if(g===null)return{location:d,value:null};const{row:y,col:f,rowOffset:b,colOffset:I,blockWidth:v}=g,w=o??t.sliceId,$=pe(this.rasterId,w),N=`${m}/${y}/${f}`;let M=ye($,null,N);M==null&&(M=this.fetchRawTile(m,y,f,t),ge($,null,N,M));const J=await M;if(!((G=J==null?void 0:J.pixels)!=null&&G.length))return{location:d,value:null};const O=b*v+I;return this._processIdentifyResult(J,{srcLocation:d,position:O,pyramidLevel:m,useTransposedTile:!!p,requestSomeSlices:l,identifyOptions:t})}async fetchPixels(i,t,r,e={}){i=pt(i),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:n}=this;if(e.requestRawData&&n)return this._fetchPixels(i,t,r,e);const s=Q(i.spatialReference),a=te(i);if(s==null||a===0||a===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(i,t,r,e);if(a>=3)return{extent:i,pixelBlock:null};const o=[],{xmin:l,xmax:c}=i,u=Math.round(s/(c-l)*t),h=u-Math.round((s/2-l)/(c-l)*t);let d=0;const m=[];for(let f=0;f<=a;f++){const b=new U({xmin:f===0?l:-s/2,xmax:f===a?c-s*f:s/2,ymin:i.ymin,ymax:i.ymax,spatialReference:i.spatialReference}),I=f===0?u-h:f===a?t-d:u;d+=I,m.push(I);const v=e.disableWrapAround&&f>0?null:this._fetchPixels(b,I,r,e);o.push(v)}const p=(await Promise.all(o)).map(f=>f==null?void 0:f.pixelBlock);let g=null;const y={width:t,height:r};return this.rasterJobHandler?g=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:m},e)).pixelBlock:g=ee(p,y,{blockWidths:m}),{extent:i,srcExtent:X(i,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:g}}async fetchRawPixels(i,t,r,e={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const n=await this._fetchRawTiles(i,t,r,e),{nativeExtent:s,nativePixelSize:a,storageInfo:o}=this.rasterInfo,l=2**i,c=a.x*l,u=a.y*l,h=new U({xmin:s.xmin+c*t.x,xmax:s.xmin+c*(t.x+r.width-1),ymin:s.ymax-u*(t.y+r.height-1),ymax:s.ymax-u*t.y,spatialReference:s.spatialReference});if(!n)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:d,mosaicSize:m}=n;if(d.length===1&&d[0]!=null&&d[0].width===r.width&&d[0].height===r.height)return{extent:h,srcExtent:h,pixelBlock:n.pixelBlocks[0]};const p=i>0?o.pyramidBlockWidth:o.blockWidth,g=i>0?o.pyramidBlockHeight:o.blockHeight,y={x:t.x%p,y:t.y%g};let f;return this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:m,destDimension:r,clipOffset:y,clipSize:r,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:f=ee(d,m,{clipOffset:y,clipSize:r}),{extent:h,srcExtent:h,pixelBlock:f}}fetchRawTile(i,t,r,e){throw new j("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(i){return X(this.rasterInfo.extent,i)}decodePixelBlock(i,t){return!this.rasterJobHandler||t.useCanvas?rt(i,t):this.rasterJobHandler.decode({data:i,options:t})}async request(i,t,r=0){const{customFetchParameters:e}=this.ioConfig,{range:n,query:s,headers:a}=t;r=r??t.retryCount??this.ioConfig.retryCount;const o=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await Ie(i,{...t,query:{...s,...e},headers:{...a,...o}})}catch(l){if(r>0)return r--,this.request(i,t,r);throw l}}getSliceIndex(i){const{multidimensionalInfo:t}=this.rasterInfo;return t==null||i==null||i.length===0?null:We(i,t)}getTileExtentFromTileInfo(i,t,r,e){const n=e.lodAt(i);return this.getTileExtent({x:n.resolution,y:n.resolution},t,r,e.origin,e.spatialReference,e.size)}updateTileInfo(){const{storageInfo:i,spatialReference:t,extent:r,pixelSize:e}=this.rasterInfo,{pyramidResolutions:n}=i;if(!i.tileInfo){const s=[],a=i.maximumPyramidLevel||0;let o=(e.x+e.y)/2,l=1/.0254*96*o;for(let u=0;u<=a&&(s.unshift(new Je({level:a-u,resolution:o,scale:l})),u!==a);u++)if(n){const h=(n[u].x+n[u].y)/2;l*=h/o,o=h}else o*=2,l*=2;const c=new E({x:r.xmin,y:r.ymax,spatialReference:t});i.tileInfo=new Z({origin:c,size:[i.blockWidth,i.blockHeight],spatialReference:t,lods:s}),i.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(i,t=512,r=512,e){const{width:n,height:s,nativeExtent:a,pixelSize:o,spatialReference:l}=i,c=new E({x:a.xmin,y:a.ymax,spatialReference:l});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(n,s))/Math.LN2-8)));const u=this.computeBlockBoundary(a,512,512,{x:a.xmin,y:a.ymax},[o],e);i.storageInfo=new st({blockWidth:t,blockHeight:r,pyramidBlockWidth:t,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:u})}async computeBestPyramidLevelForLocation(i,t={}){return 0}computeBlockBoundary(i,t,r,e,n,s=0,a=2){if(n.length===1&&s>0){n=[...n];let{x:u,y:h}=n[0];for(let d=0;d<s;d++)u*=a,h*=a,n.push({x:u,y:h})}const o=[],{x:l,y:c}=e;for(let u=0;u<n.length;u++){const{x:h,y:d}=n[u];o.push({minCol:Math.floor((i.xmin-l+.1*h)/t/h),maxCol:Math.floor((i.xmax-l-.1*h)/t/h),minRow:Math.floor((c-i.ymax+.1*d)/r/d),maxRow:Math.floor((c-i.ymin-.1*d)/r/d)})}return o}getPyramidPixelSize(i){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(i===0)return t;if(r!=null&&r.length)return r[i-1];const n=e**i;return{x:t.x*n,y:t.y*n}}identifyPixelLocation(i,t,r,e){const{spatialReference:n,nativeExtent:s,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:o,origin:l,transposeInfo:c}=a,u=e&&c!=null?c.tileSize[0]:a.blockWidth,h=e&&c!=null?c.tileSize[1]:a.blockHeight,d=fe(i,n,r);if(!s.intersects(d)||t<0||t>o)return null;const m=this.getPyramidPixelSize(t),{x:p,y:g}=m,y=(l.y-d.y)/g/h,f=(d.x-l.x)/p/u,b=Math.min(h-1,Math.floor((y-Math.floor(y))*h)),I=Math.min(u-1,Math.floor((f-Math.floor(f))*u));return{pyramidLevel:t,row:Math.floor(y),col:Math.floor(f),rowOffset:b,colOffset:I,blockWidth:u,srcLocation:d}}getTileExtent(i,t,r,e,n,s){const[a,o]=s,l=e.x+r*a*i.x,c=l+a*i.x,u=e.y-t*o*i.y,h=u-o*i.y;return new U({xmin:l,xmax:c,ymin:h,ymax:u,spatialReference:n})}getBlockWidthHeight(i){return{blockWidth:i>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:i>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(i,t,r){const e=this.rasterInfo.storageInfo.blockBoundary[i];return!e||e.maxRow<t||e.maxCol<r||e.minRow>t||e.minCol>r}updateImageSpaceRasterInfo(i){const{pixelSize:t}=i,{width:r,height:e}=i,n=we.WebMercator;i.spatialReference=n,i.extent=i.nativeExtent=new U({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-e,spatialReference:n}),i.isPseudoSpatialReference=!0,i.transform=null,i.pixelSize=new E({x:1,y:1,spatialReference:n});const{extent:s,storageInfo:a}=i;if(a){a.origin=new E({x:s.xmin,y:s.ymax,spatialReference:n});const{pyramidResolutions:o,tileInfo:l}=a;if(o&&o.forEach(c=>{c.x/=t.x,c.y/=t.y}),l){l.origin=a.origin;const c=(i.nativePixelSize.x+i.nativePixelSize.y)/2;l.lods.forEach((u,h)=>{u.resolution=c*2**h,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(i,t,r,e={}){let n=te(i);if(n>=2)return{extent:i,pixelBlock:null};const s=this._getSourceDataInfo(i,t,r,e),{pyramidLevel:a,srcResolution:o,srcExtent:l,srcWidth:c,srcHeight:u,ul:h}=s;if(c===0||u===0)return{extent:i,srcExtent:l,pixelBlock:null};const{rasterInfo:d}=this,m=d.transform,p=(m==null?void 0:m.type)==="gcs-shift",g=Q(i.spatialReference)!=null;!p&&g||(n=te(s.srcExtent,p));const y=await this._fetchRawTiles(a,h,{width:c,height:u,wrapCount:n},e);if(!y)return{extent:i,srcExtent:l,pixelBlock:null};const f=d.storageInfo,b=a>0?f.pyramidBlockWidth:f.blockWidth,I=a>0?f.pyramidBlockHeight:f.blockHeight;let{x:v,y:w}=d.pixelSize;if(a>0){const{pyramidResolutions:P,pyramidScalingFactor:Pe}=f;if(P!=null&&P[a-1])({x:v,y:w}=P[a-1]);else{const oe=Pe**a;v*=oe,w*=oe}}const $=d.spatialReference,N=new E({x:v,y:w,spatialReference:$}),M=b===c&&I===u&&h.x%b==0&&h.y%I==0,J=new E({x:(i.xmax-i.xmin)/t,y:(i.ymax-i.ymin)/r,spatialReference:i.spatialReference}),O=!i.spatialReference.equals($),G=$.isGeographic?1e-9:1e-4,{datumTransformation:B}=e;if(!O&&M&&y.pixelBlocks.length===1&&b===t&&I===r&&kt(o,J,G))return{extent:i,srcExtent:l,srcTilePixelSize:N,pixelBlock:y.pixelBlocks[0]};const q=g&&Q(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,_=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");_&&!this.rasterJobHandler&&await ne();const k=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:i,srcBufferExtent:y.extent,pixelSize:J.toJSON(),datumTransformation:B,rasterTransform:m,hasWrapAround:n>0||q,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:_},e):yt({projectedExtent:i,srcBufferExtent:y.extent,pixelSize:J,datumTransformation:B,rasterTransform:m,hasWrapAround:n>0||q,isAdaptive:!1,includeGCSGrid:_});let H;const z=!e.requestRawData,W={rows:k.spacing[0],cols:k.spacing[1]},T=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(a,y.extent.xmin):void 0,{pixelBlocks:F,mosaicSize:C,isPartiallyFilled:V}=y;let D=null;if(this.rasterJobHandler)({pixelBlock:H,localNorthDirections:D}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:F,srcMosaicSize:C,destDimension:z?{width:t,height:r}:null,coefs:z?k.coefficients:null,sampleSpacing:z?W:null,projectDirections:_,gcsGrid:_?k.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:T,blockWidths:null},e));else{const P=ee(F,C,{alignmentInfo:T});H=z?ke(P,{width:t,height:r},k.coefficients,W,e.interpolation):P,_&&k.gcsGrid&&(D=at({width:t,height:r},k.gcsGrid),H=ot(H,this.rasterInfo.dataType,D))}return e.requestRawData||_?{extent:i,srcExtent:l,srcTilePixelSize:N,pixelBlock:H,transformGrid:k,localNorthDirections:D,isPartiallyFilled:V}:{extent:i,srcExtent:l,srcTilePixelSize:N,pixelBlock:H}}async _fetchRawTiles(i,t,r,e){const{origin:n,blockBoundary:s}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:o}=this.getBlockWidthHeight(i);let{x:l,y:c}=t,{width:u,height:h,wrapCount:d}=r;const m=this._getRasterTileAlignmentInfo(i,0);e.buffer&&(l-=e.buffer.cols,c-=e.buffer.rows,u+=2*e.buffer.cols,h+=2*e.buffer.rows);let p=0,g=0,y=0;d&&m!=null&&({worldColumnCountFromOrigin:g,originColumnOffset:y,rightPadding:p}=m,g*m.blockWidth-p>=l+u&&(p=0));const f=Math.floor(l/a),b=Math.floor(c/o),I=Math.floor((l+u+p-1)/a),v=Math.floor((c+h+p-1)/o),w=s[i];if(!w)return null;const{minRow:$,minCol:N,maxCol:M,maxRow:J}=w;if(d===0&&(v<$||I<N||b>J||f>M))return null;const O=new Array;let G=!1;const B=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let T=b;T<=v;T++)for(let F=f;F<=I;F++){let C=F;if(!e.disableWrapAround&&d&&m!=null&&g<=F&&(C=F-g-y),T>=$&&C>=N&&J>=T&&M>=C){const V=this._tileFetchQueue.push({pyramidLevel:i,row:T,col:C,options:e},{signal:e.signal});B?O.push(new Promise(D=>{V.then(P=>D(P)).catch(()=>{G=!0,D(null)})})):O.push(V)}else O.push(Promise.resolve(null))}if(O.length===0)return null;const q=await Promise.all(O),_={height:(v-b+1)*o,width:(I-f+1)*a},{spatialReference:k}=this.rasterInfo,H=this.getPyramidPixelSize(i),{x:z,y:W}=H;return{extent:new U({xmin:n.x+f*a*z,xmax:n.x+(I+1)*a*z,ymin:n.y-(v+1)*o*W,ymax:n.y-b*o*W,spatialReference:k}),pixelBlocks:q,mosaicSize:_,isPartiallyFilled:G}}_fetchRawTile(i,t,r,e){const n=this.rasterInfo.storageInfo.blockBoundary[i];if(!n)return Promise.resolve(null);const{minRow:s,minCol:a,maxCol:o,maxRow:l}=n;if(t<s||r<a||t>l||r>o)return Promise.resolve(null);const c=pe(this.rasterId,e.sliceId),u=`${i}/${t}/${r}`;let h=ye(c,e.registryId,u);if(h==null){const d=new AbortController;h=this.fetchRawTile(i,t,r,{...e,signal:d.signal}),ge(c,e.registryId,u,h,d),h.catch(()=>_t(c,e.registryId,u))}return e.signal&&Be(e,()=>{wt(c,e.registryId,u)}),h}_computeMagDirValues(i){var l;const{bandCount:t,dataType:r}=this.rasterInfo;if(!(t===2&&r==="vector-magdir"||r==="vector-uv")||(i==null?void 0:i.length)!==2||!((l=i[0])!=null&&l.length))return null;const e=i[0].length;if(r==="vector-magdir"){const c=i[1].map(u=>(u+360)%360);return[i[0],c]}const[n,s]=i,a=[],o=[];for(let c=0;c<e;c++){const[u,h]=lt([n[c],s[c]]);a.push(u),o.push(h)}return[a,o]}_getRasterTileAlignmentInfo(i,t){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=gt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[i]}}_getSourceDataInfo(i,t,r,e={}){const n={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(n.srcResolution=e.srcResolution,this._updateSourceDataInfo(i,n));const s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:a,srcHeight:o,pyramidLevel:l}=n,c=a/t,u=o/r,h=l<s&&c*u>=16,d=l===s&&this._requireTooManySrcTiles(a,o,t,r);if(h||d||a===0||o===0){const m=new E({x:(i.xmax-i.xmin)/t,y:(i.ymax-i.ymin)/r,spatialReference:i.spatialReference});let p=xt(m,this.rasterInfo.spatialReference,i,n.datumTransformation);const g=!p||e.srcResolution&&p.x+p.y<e.srcResolution.x+e.srcResolution.y;if(h&&e.srcResolution&&g){const y=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(s-l+3>=y){const f=2**y;p={x:e.srcResolution.x*f,y:e.srcResolution.y*f}}}p&&(n.srcResolution=p,this._updateSourceDataInfo(i,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,t,r)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(i,t,r,e){const{tileInfo:n}=this.rasterInfo.storageInfo,s=Math.ceil(i/n.size[0])*Math.ceil(t/n.size[1]),a=i/r,o=t/e,l=Math.max(1,(r+e)/1024);return s>=St*l||a>xe||o>xe}_updateSourceDataInfo(i,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:r}=this,e=r.spatialReference,{srcResolution:n,datumTransformation:s}=t,{pyramidLevel:a,pyramidResolution:o,excessiveReading:l}=me(n,r,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||X(i,e,s);if(c==null)return;const u=r.transform;u&&(c=u.inverseTransform(c)),t.srcExtent=c;const{x:h,y:d}=r.storageInfo.origin,m=Math.floor((c.xmin-h)/o.x+.1),p=Math.floor((d-c.ymax)/o.y+.1),g=Math.floor((c.xmax-h)/o.x-.1),y=Math.floor((d-c.ymin)/o.y-.1),f=c.width<.1*o.x?0:g-m+1,b=c.height<.1*o.y?0:y-p+1;t.pyramidLevel=a,t.pyramidResolution=o,t.srcWidth=f,t.srcHeight=b,t.ul={x:m,y:p}}_getRequestOptionsWithSliceId(i){return this.rasterInfo.multidimensionalInfo!=null&&i.sliceId==null&&(i={...i,sliceId:this.getSliceIndex(i.multidimensionalDefinition)}),i}_processIdentifyResult(i,t){const{srcLocation:r,position:e,pyramidLevel:n,useTransposedTile:s}=t,a=i.pixels[0].length/i.width/i.height;if(!(!i.mask||i.mask[e]))return{location:r,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!s){const y=i.pixels.map(I=>I[e]),f={location:r,value:y,pyramidLevel:n},b=this._computeMagDirValues(y.map(I=>[I]));return b!=null&&b.length&&(f.magdirValue=b.map(I=>I[0])),f}let l=i.pixels.map(y=>y.slice(e*a,e*a+a)),c=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:h}=t;let d=Le(o,h.transposedVariableName);if(u){const y=Ge(d,h.multidimensionalDefinition,h.timeExtent);l=l.map(f=>y.map(b=>f[b])),c=c==null?void 0:c.map(f=>y.map(b=>f[b])),d=y.map(f=>d[f])}const m=i.noDataValues||this.rasterInfo.noDataValue,p={pixels:l,pixelType:i.pixelType};let g;return m!=null&&(He(p,m),g=p.mask),{location:r,value:null,dataSeries:d.map((y,f)=>{const b={value:(g==null?void 0:g[f])===0?null:l.map(I=>I[f]),multidimensionalDefinition:y.multidimensionalDefinition.map(I=>new ve({...I,isSlice:!0}))};return c!=null&&c.length&&(b.magdirValue=[c[0][f],c[1][f]]),b}),pyramidLevel:n}}};function kt(i,t,r){return Math.abs(i.x-t.x)<r&&Math.abs(i.y-t.y)<r}x([R()],S.prototype,"_rasterTileAlignmentInfo",void 0),x([R()],S.prototype,"_tileFetchQueue",void 0),x([R({readOnly:!0})],S.prototype,"_isGlobalWrappableSource",null),x([R({readOnly:!0})],S.prototype,"_hasNoneOrGCSShiftTransform",null),x([R()],S.prototype,"_openPromise",void 0),x([R()],S.prototype,"rasterJobHandler",null),x([R({readOnly:!0})],S.prototype,"rasterId",null),x([R(_e)],S.prototype,"url",null),x([R({type:String,json:{write:!0}})],S.prototype,"datasetName",void 0),x([R({type:String,json:{write:!0}})],S.prototype,"datasetFormat",void 0),x([R()],S.prototype,"hasUniqueSourceStorageInfo",void 0),x([R()],S.prototype,"rasterInfo",void 0),x([R()],S.prototype,"ioConfig",void 0),x([R()],S.prototype,"sourceJSON",void 0),S=x([ae("esri.layers.support.rasterDatasets.BaseRaster")],S);const Tt=S,Ft=40;let A=class extends Tt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(i,t,r,e={}){var I,v;const{rasters:n,rasterIds:s}=this.primaryRasters;let a=!1;const{interpolation:o}=e,l=(I=this.rasterFunction.flatWebGLFunctionChain)==null?void 0:I.hasFocalFunction;!e.requestRawData&&l&&(a=n.length===1&&!e.skipRasterFunction,e={...e,interpolation:"bilinear",requestRawData:a});const c=n.map(w=>w.fetchPixels(i,t,r,e)),u=await Promise.all(c),h=u.map(w=>w.pixelBlock),d=a||e.requestRawData?u.map(w=>w.srcTilePixelSize):null;if(e.skipRasterFunction||h.every(w=>w==null))return u[0];const m=((v=u.find(w=>w.pixelBlock!=null))==null?void 0:v.extent)??i;let p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:m,primaryPixelBlocks:h,primaryPixelSizes:d,primaryRasterIds:s}):this.rasterFunction.process({extent:m,primaryPixelBlocks:h,primaryPixelSizes:d,primaryRasterIds:s});const{transformGrid:g}=u[0];if(!a||p==null||g==null){const w=e.noClip?null:this.getClippingGeometry(m.spatialReference);return e.noClip||e.requestRawData||p==null||!w||(p=await se(p,m,w)),{...u[0],pixelBlock:p}}const y={rows:g.spacing[0],cols:g.spacing[1]};let f;this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:t,height:r},coefs:g.coefficients,sampleSpacing:y,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},e)).pixelBlock:f=ke(p,{width:t,height:r},g.coefficients,y,o);const b=e.noClip?null:this.getClippingGeometry(i.spatialReference);return e.noClip||e.requestRawData||f==null||b==null||(f=await se(f,i,b)),{extent:i,srcExtent:u[0].srcExtent,pixelBlock:f}}getClippingGeometry(i){const t=this._clippingGeometry.get("0");if(!i||!t)return t;const r=Jt(i);let e=this._clippingGeometry.get(r);return e!=null||(e=i.equals(t.spatialReference)?t:re(t,i),this._clippingGeometry.set(r,e)),e}async _open(i){var c,u,h,d;const{rasterFunction:t}=this;(u=(c=this.primaryRasters)==null?void 0:c.rasters)!=null&&u.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&((h=this.primaryRasters.rasters)==null||h.forEach(m=>m.rasterJobHandler=this.rasterJobHandler)));const{rasters:r,rasterIds:e}=this.primaryRasters,n=r.map(m=>m.rasterInfo?void 0:m.open(i));await Promise.all(n);const s=r.map(({rasterInfo:m})=>m),a=t.bind({rasterInfos:s,rasterIds:e});if(t.rawSourceRasterInfos=s,!a.success||s.length===0)throw new j("raster-function:open",`cannot bind the function: ${a.error??""}`);const o=t.functionName==="Table"?t:(d=t.functionArguments)==null?void 0:d.raster;(o==null?void 0:o.functionName)==="Table"&&(t.rasterInfo.attributeTable=ze.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=s[0];this.hasUniqueSourceStorageInfo=s.length===1||s.slice(1).every(m=>Ct(m,l)),this.set("sourceJSON",r[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var i;return(i=this.rasterJobHandler)==null?void 0:i.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const i=this.rasterFunction.getClippingGeometries()[0];let t=i==null?void 0:i.clippingGeometry;if(t&&i.clippingType==="inside"){const{extent:r}=this.rasterInfo,{difference:e,densify:n}=await De(async()=>{const{difference:a,densify:o}=await import("./geometryEngine-DEWZpdAD.js");return{difference:a,densify:o}},__vite__mapDeps([0,1,2,3,4,5]));let s=n($e.fromExtent(r),2*(r.width+r.height)/Ft);s=re(s,t.spatialReference),t=e(s,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};x([R({type:String,json:{write:!0}})],A.prototype,"datasetFormat",void 0),x([R()],A.prototype,"tileType",void 0),x([R()],A.prototype,"rasterFunction",void 0),x([R()],A.prototype,"primaryRasters",void 0),A=x([ae("esri.layers.support.rasterDatasets.FunctionRaster")],A);const Pt=A;function Ct(i,t){const{storageInfo:r,pixelSize:e,spatialReference:n,extent:s}=i,{storageInfo:a,pixelSize:o,spatialReference:l,extent:c}=t;return e.x===o.x&&e.y===o.y&&n.equals(l)&&s.equals(c)&&r.blockHeight===a.blockHeight&&r.blockWidth===a.blockWidth&&r.maximumPyramidLevel===a.maximumPyramidLevel}function Jt(i){return String(i.wkid??i.wkt??i.wkt2)}const Et=i=>{let t=class extends i{constructor(...e){var n,s;super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=((s=(n=e[0])==null?void 0:n.raster)==null?void 0:s.datasetFormat)==="Function"}get fullExtent(){var e;return(e=this.serviceRasterInfo)==null?void 0:e.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){var n;((n=e==null?void 0:e.functionName)==null?void 0:n.toLowerCase())==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",Re(e,ie.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;if(e){const s=n==null?void 0:n.find(({name:a})=>a===e);return s==null?void 0:s.renderer.clone()}return this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,s){var o,l;const a=(l=(o=n==null?void 0:n.layerDefinition)==null?void 0:o.drawingInfo)==null?void 0:l.renderer;return Ve(a,s)||void 0}async convertVectorFieldData(e,n){const{serviceRasterInfo:s}=this;if(e==null||!s)return null;const a=this._rasterJobHandler.instance,o=s.dataType;return a?a.convertVectorFieldData({pixelBlock:e,dataType:o},n):ct(e,o)}async computeStatisticsHistograms(e,n){await this.load(n),e=be(Ue,e).clone();const{serviceRasterInfo:s}=this;if(s==null)throw new j("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:a}=e;if(a==null)throw new j("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let o=a;const{spatialReference:l}=s;a.spatialReference.equals(l)||(await ne(),o=a.type==="extent"?X(a,l):re(a,l));const c=e.pixelSize??new E({x:s.pixelSize.x,y:s.pixelSize.y,spatialReference:l}),{extent:u,width:h,height:d}=Rt(s,o,c),m=await this.fetchPixels(u,h,d,{...n,interpolation:"nearest"});if(m.pixelBlock==null)throw new j("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const p=await se(m.pixelBlock,u,o),g=this._rasterJobHandler.instance;return g?g.computeStatisticsHistograms({pixelBlock:p},n):ut(p)}async createFlowMesh(e,n){const s=this._rasterJobHandler.instance;return s?s.createFlowMesh(e,n):ht(e.meshType,e.simulationSettings,e.flowData,n.signal!=null?n.signal:new AbortController().signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const s=Qe({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:s}}async updateRasterFunction(){var e;return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=(e=this.rasterFunction)==null?void 0:e.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n}=this;if(!e||!n||!this.renderer)return;const{rasterInfo:s}=this.raster,a=ce(s,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=a==null?void 0:a.name,l=ue({...this.renderer.toJSON(),variableName:o});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(l))return;const c=this._rasterJobHandler.instance;c&&(n.rasterInfo=he(s,o),n.rendererJSON=l,n.bind(),await c.updateSymbolizer(n),this._cachedRendererJson=l)}async applyRenderer(e,n){const s=e==null?void 0:e.pixelBlock;if(!(s!=null&&s.pixels&&s.pixels.length>0))return null;let a;await this.updateRenderer();const o=this._rasterJobHandler.instance,l=this.bandIds??[];return a=o?await o.symbolize({...e,simpleStretchParams:n,bandIds:l}):this.symbolizer.symbolize({...e,simpleStretchParams:n,bandIds:l}),a}getTileUrl(e,n,s){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${s}`:""}getCompatibleTileInfo(e,n,s=!1){if(!this.loaded||n==null)return null;if(s&&e.equals(this.spatialReference))return this.tileInfo;const a=Ee(e);return Z.create({size:256,spatialReference:e,origin:a?{x:a.origin[0],y:a.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){var n;return this.loaded?((n=this._compatibleFullExtent)!=null&&n.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,s,a={}){var l;if(r(this),a.requestAsImageElement){const c=this.getTileUrl(e,n,s);return Ie(c,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:a.signal}).then(u=>u.data)}const{serviceRasterInfo:o}=this;if(o.multidimensionalInfo!=null&&(a=this.normalizeRasterFetchOptions(a)).multidimensionalDefinition==null){const c=a.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,n,s,c),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),((l=this.renderer)==null?void 0:l.type)==="raster-shaded-relief"&&(a={...a,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,s,a)}async fetchPixels(e,n,s,a={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(a=this.normalizeRasterFetchOptions(a)).multidimensionalDefinition==null?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),s=Math.round(s),this.raster.fetchPixels(e,n,s,a))}async identify(e,n={}){var l;await this.load();const{raster:s,serviceRasterInfo:a}=this;if((a==null?void 0:a.multidimensionalInfo)!=null&&!(a.hasMultidimensionalTranspose&&(Se(n.multidimensionalDefinition)||n.transposedVariableName||n.timeExtent))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const o=(l=this.multidimensionalSubset)==null?void 0:l.areaOfInterest;if(o&&!o.contains(e))throw new j("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return s.identify(e,n)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){var a,o,l;const e=(a=this.serviceRasterInfo)==null?void 0:a.multidimensionalInfo;if(e==null||((o=this.serviceRasterInfo)==null?void 0:o.dataType)!=="standard-time")return!1;const n=this.multidimensionalDefinition,s=(l=n==null?void 0:n[0])==null?void 0:l.variableName;return e.variables.some(c=>c.name===s&&(!(n!=null&&n[0].dimensionName)||c.dimensions.some(u=>u.name==="StdTime")))}getStandardTimeValue(e){return new Date(Xe(e)).toISOString()}getMultidimensionalSubsetVariables(e){var s;const n=e??((s=this.serviceRasterInfo)==null?void 0:s.multidimensionalInfo);return Ze(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Ke(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&this.raster.datasetFormat==="Function"&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(this._rasterJobHandler.connectionPromise!=null)return this._rasterJobHandler.connectionPromise;const e=new Ye;return this._rasterJobHandler.connectionPromise=e.initialize().then(async()=>{r(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.raster.datasetFormat==="Function"&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){var e;if(this.interpolation==null){r(this);const{raster:n}=this,s=et(n.rasterInfo,n.tileType,(e=this.sourceJSON)==null?void 0:e.defaultResamplingMethod);this._set("interpolation",s)}}_configDefaultRenderer(e="no"){var h,d,m;r(this);const{rasterInfo:n}=this.raster,s=ce(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),a=s==null?void 0:s.name,o=tt({variableName:a,rasterFunctionName:(h=this.rasterFunction)==null?void 0:h.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=(o==null?void 0:o.bandIds)??it(n)),!this.renderer||e==="override"){const p=nt(this.raster),g=(o==null?void 0:o.renderer)??de(n,{bandIds:this.bandIds,variableName:a,rasterFunctionColorRamp:p}),y=n.statistics,f=y&&y.length>0?y[0]:null,b=(f==null?void 0:f.max)??0,I=(f==null?void 0:f.min)??0;this.raster.datasetFormat==="WCSServer"&&g.type==="raster-stretch"&&(b>1e24||I<-1e24)&&(g.dynamicRangeAdjustment=!0,g.customStatistics=null,g.stretchType==="none"&&(g.stretchType="min-max")),this.renderer=g}const l=ue({...this.renderer.toJSON(),variableName:a}),c=he(n,a);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=c):this.symbolizer=new dt({rendererJSON:l,rasterInfo:c});const u=this.symbolizer.bind();if(u.success){if(e==="auto"){const{colormap:p}=this.raster.rasterInfo,g=this.renderer;if(p!=null&&g.type==="raster-colormap"){const y=de(this.raster.rasterInfo);JSON.stringify(y)!==JSON.stringify(g)&&this._configDefaultRenderer("override")}else if(g.type==="raster-stretch"){const y=(d=this.bandIds)==null?void 0:d.length,f=(m=g.customStatistics)==null?void 0:m.length;!g.dynamicRangeAdjustment&&f&&y&&f!==y&&this._configDefaultRenderer("override")}}}else ie.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){var u;if(this._isConstructedFromFunctionRaster&&this.raster.datasetFormat==="Function"){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",le.fromJSON(h)))}let e,n=this.raster,s=!1;n.datasetFormat==="Function"?(e=n.primaryRasters.rasters,n=e[0],s=!0):e=[n];const{rasterFunction:a}=this;if(a){const h={raster:n};e.length>1&&e.forEach(p=>h[p.url]=p);const d=bt(((u=a.functionDefinition)==null?void 0:u.toJSON())??a.toJSON(),h),m=new Pt({rasterFunction:d});m.rasterJobHandler=this._rasterJobHandler.instance,await m.open(),this.raster=m}else this.raster=n,await n.open();if(this._cachedRendererJson=null,!s&&!a)return;const{bandIds:o}=this,{bandCount:l}=this.raster.rasterInfo,c=o!=null&&o.length?o.some(h=>h>=l):l>=3;o&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}};function r(e){if(!e.raster||!e.serviceRasterInfo)throw new j("imagery-tile","no raster")}return x([R({clonable:!1})],t.prototype,"_cachedRendererJson",void 0),x([R({clonable:!1})],t.prototype,"_cachedRasterFunctionJson",void 0),x([R({clonable:!1})],t.prototype,"_compatibleFullExtent",void 0),x([R({clonable:!1})],t.prototype,"_isConstructedFromFunctionRaster",void 0),x([R({clonable:!1})],t.prototype,"_rasterJobHandler",void 0),x([R({clonable:!1})],t.prototype,"_rasterFunctionUpdatePromise",void 0),x([R({type:[Ne],json:{write:{overridePolicy(){var e;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((e=this.bandIds)==null?void 0:e.join(","))!=="0,1,2"}}}}})],t.prototype,"bandIds",void 0),x([R({json:{origins:{service:{read:{source:"copyrightText"}}}}})],t.prototype,"copyright",void 0),x([R({json:{read:!1}})],t.prototype,"fullExtent",null),x([R({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Me(ft)],t.prototype,"interpolation",void 0),x([R()],t.prototype,"ioConfig",void 0),x([R({type:[ve],json:{write:!0}})],t.prototype,"multidimensionalDefinition",null),x([R({type:qe,json:{write:!0}})],t.prototype,"multidimensionalSubset",void 0),x([R()],t.prototype,"raster",void 0),x([R({type:le})],t.prototype,"rasterFunction",null),x([R()],t.prototype,"serviceRasterInfo",void 0),x([R()],t.prototype,"sourceJSON",void 0),x([R({readOnly:!0,type:we,json:{read:!1}})],t.prototype,"spatialReference",void 0),x([R({type:Z})],t.prototype,"tileInfo",void 0),x([R(_e)],t.prototype,"url",null),x([R()],t.prototype,"renderer",null),x([R({types:je,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var n;const e=((n=this.renderer)==null?void 0:n.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ae,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],t.prototype,"internalRenderer",null),x([Oe("internalRenderer")],t.prototype,"readRenderer",null),x([R({clonable:!1})],t.prototype,"symbolizer",void 0),t=x([ae("esri.layers.mixins.ImageryTileMixin")],t),t};function K(i,t){if(!i||!t)return[];let r=t;t.includes("/")?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const e=[];if(t){const s=K(i,r);for(let a=0;a<s.length;a++)K(s[a],t).forEach(o=>e.push(o));return e}const n=i.getElementsByTagNameNS("*",r);if(!n||n.length===0)return[];for(let s=0;s<n.length;s++)e.push(n[s]||n.item(s));return e}function Te(i,t){if(!i||!t)return null;let r=t;t.includes("/")?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const e=K(i,r);return e.length>0?t?Te(e[0],t):e[0]:null}function Fe(i,t=null){const r=t?Te(i,t):i;let e;return r?(e=r.textContent||r.nodeValue,e?e.trim():null):null}function Bt(i,t){const r=K(i,t),e=[];let n;for(let s=0;s<r.length;s++)n=r[s].textContent||r[s].nodeValue,n&&(n=n.trim(),n!==""&&e.push(n));return e}function Wt(i,t=null){const r=Fe(i,t);return(r==null?void 0:r.split(" ").map(e=>Number(e)))??[]}function Lt(i,t){return Bt(i,t).map(r=>Number(r))}function Gt(i,t){const r=Fe(i,t);return Number(r)}function qt(i,t){var n;const r=(n=i==null?void 0:i.nodeName)==null?void 0:n.toLowerCase(),e=t.toLowerCase();return r.slice(r.lastIndexOf(":")+1)===e}function At(i){return i.nodeName.slice(i.nodeName.lastIndexOf(":")+1)}export{Et as K,Tt as X,Pt as a,At as c,Te as e,qt as i,Bt as l,K as n,Gt as o,Wt as r,Fe as t,Lt as u};
