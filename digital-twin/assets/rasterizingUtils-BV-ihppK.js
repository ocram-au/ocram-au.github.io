import{jY as I,k as $,jZ as S}from"./index-QRcEofMq.js";import"./definitions-DKtXO-DI.js";const v=15.5,P=1024,R=()=>$.getLogger("esri.symbols.cim.rasterizingUtils");function j(n,a){n==null&&(n=[]);const o=a==="Butt",r=a==="Square",e=!o&&!r;n.length%2==1&&(n=[...n,...n]);const t=v,s=2*t;let l=0;for(const p of n)l+=p;const c=Math.round(l*t),i=new Float32Array(c*s),h=.5*t;let f=0,u=0,m=.5,x=!0;for(const p of n){for(f=u,u+=p*t;m<=u;){let g=.5;for(;g<s;){const b=(g-.5)*c+m-.5,C=e?(g-t)*(g-t):Math.abs(g-t);i[b]=x?o?Math.max(Math.max(f+h-m,C),Math.max(m-u+h,C)):C:e?Math.min((m-f)*(m-f)+C,(m-u)*(m-u)+C):r?Math.min(Math.max(m-f,C),Math.max(u-m,C)):Math.min(Math.max(m-f+h,C),Math.max(u+h-m,C)),g++}m++}x=!x}const y=i.length,w=new Uint8Array(4*y);for(let p=0;p<y;++p){const g=(e?Math.sqrt(i[p]):i[p])/t;S(g,w,4*p)}return[w,c,s]}let d;function A(n,a){const{colorRamp:o,gradientType:r}=a,e=N(o),t=o.type==="CIMFixedColorRamp";if(r==="Continuous"&&!t)return M(n,e);const s=a.interval??I.CIMGradientFill.interval;if(t)return M(n,F(e,s));const l=[];d??(d=document.createElement("canvas")),k(d,e,s,1,0);const c=d.getContext("2d").getImageData(0,0,s,1).data;for(let i=0,h=0;i<s;i++,h=4*i){const f=[c[h+0],c[h+1],c[h+2],c[h+3]];l.push({offset:i/s,color:f}),l.push({offset:(i+1)/s,color:f})}return M(n,l)}function N(n){const a=[];switch(n.type){case"CIMPolarContinuousColorRamp":case"CIMLinearContinuousColorRamp":{n.type==="CIMPolarContinuousColorRamp"&&R().warnOnce("CIMPolarContinuousColorRamp is currently unsupported. Falling back to CIMLinearContinuousColorRamp.");const o=n;a.push({offset:0,color:[o.fromColor[0],o.fromColor[1],o.fromColor[2],o.fromColor[3]/255]}),a.push({offset:1,color:[o.toColor[0],o.toColor[1],o.toColor[2],o.toColor[3]/255]});break}case"CIMFixedColorRamp":{const o=n,r=1/(o.colors.length-1);let e=0;for(const t of o.colors)a.push({offset:e,color:[t[0],t[1],t[2],t[3]/255]}),e+=r;break}case"CIMMultipartColorRamp":{const o=n,r=o.weights.reduce((t,s)=>t+s,0);let e=0;for(let t=0;t<o.colorRamps.length;t++){const s=o.colorRamps[t],l=o.weights[t],c=N(s);for(const i of c)a.push({offset:(e+i.offset*l)/r,color:i.color});e+=l}break}default:R().error(`Color ramp "${n.type}" currently unsupported.`)}return a}function F(n,a){const o=[],r=(n.length-1)/(a-1);for(let e=0;e<a;e++){const t=n[Math.round(e*r)].color;o.push({offset:e/a,color:t}),o.push({offset:(e+1)/a,color:t})}return o}function M(n,a,o=0){for(const{offset:r,color:e}of a)n.addColorStop(Math.min(Math.max(r,o),1-o),`rgba(${e[0]}, ${e[1]}, ${e[2]}, ${e[3]})`)}function k(n,a,o,r,e){const t=o+2*e;n.width=t,n.height=r;const s=(e+1)/t,l=n.getContext("2d",{willReadFrequently:!0});if(a.length>0){const c=l.createLinearGradient(0,0,t,r);M(c,a,s),l.fillStyle=c}else l.fillStyle="rgba(128, 128, 128, 1)";l.fillRect(0,0,t,r)}function L(n){var e,t,s,l;const a=((t=(e=n[0])==null?void 0:e[0])==null?void 0:t[0])??0,o=((l=(s=n[0])==null?void 0:s[0])==null?void 0:l[1])??0,r={ymin:o,xmin:a,ymax:o,xmax:a,width:0,height:0};for(let c=0;c<n.length;c++){const i=n[c];for(let h=0;h<i.length;h++){const f=i[h][0],u=i[h][1];f<r.xmin&&(r.xmin=f),f>r.xmax&&(r.xmax=f),u<r.ymin&&(r.ymin=u),u>r.ymax&&(r.ymax=u)}}return r.width=Math.abs(r.xmax-r.xmin),r.height=Math.abs(r.ymax-r.ymin),r}function G(n,a){const o=L(n),r=o.width===0?1:o.width,e=o.height===0?1:o.height,t=[];for(let s=0;s<n.length;s++){const l=n[s],c=[];for(let i=0;i<l.length;i++){let h=Math.round(l[i][0]-o.xmin),f=Math.round(l[i][1]-o.ymin);if(h=a.xmin+h*a.width/r,f=a.ymin+f*a.height/e,isNaN(h)||isNaN(f))throw new Error("Scaled shape has NaN values");c.push([h,f])}t.push(c)}return t}function T(n,a,o){const r=[];for(let e=0;e<n.length;e++){const t=n[e],s=[];for(let l=0;l<t.length;l++){const c=t[l][0]+a,i=t[l][1]+o;if(isNaN(c)||isNaN(i))throw new Error("Scaled shape has NaN values");s.push([c,i])}r.push(s)}return r}export{T as R,G as T,P as e,A as p,j as u};
