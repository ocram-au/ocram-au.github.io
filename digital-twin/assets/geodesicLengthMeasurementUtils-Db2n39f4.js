import{mj as v,cv as Q,av as ft,fX as V,mk as pt,m as P,c5 as st,as as dt,j as Mt,ml as mt,mm as gt,ec as $t,bk as Z,du as yt,cJ as wt,kn as Rt,dt as vt,mn as jt,ko as at,ch as zt,mo as H}from"./index-Bi7V-lOi.js";import{geodesicLength as rt}from"./geometryEngine-rz8Ge1da.js";function it(t){if(!t)return null;if(V(t)&&t.wkid){const n=pt[t.wkid];if(n)return n}const e=t.wkt2||t.wkt;if(e){const n=qt(e);if(n)return n}return null}function qt(t){const e=mt.exec(t);if(!e||e.length!==2)return null;const n=e[1].split(",");if(!n||n.length<3)return null;const s=parseFloat(n[1]),a=parseFloat(n[2]);return isNaN(s)||isNaN(a)?null:{a:s,f:a===0?0:1/a}}function J(t){const e=it(t);if(bt(e))return e;const n=e.a*(1-e.f);return Object.assign(e,{b:n,eSq:1-(n/e.a)**2,radius:(2*e.a+n)/3,densificationRatio:1e4/((2*e.a+n)/3)})}function bt(t){return t!=null&&"b"in t&&"eSq"in t&&"radius"in t}function T(t,e,n){const{a:s,eSq:a}=J(n),r=Math.sqrt(a),c=Math.sin(e[1]*v),i=s*e[0]*v;let l;return a>0?l=s*((1-a)*(c/(1-a*(c*c))-1/(2*r)*Math.log((1-r*c)/(1+r*c))))*.5:l=s*c,t[0]=i,t[1]=l,t}function F(t){return it(t)!==null}function Ot(t,e="square-meters"){if(t.some(c=>!F(c.spatialReference)))throw new P("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let c=0;c<t.length;c++){const i=t[c],l=i.spatialReference,{radius:u,densificationRatio:h}=J(l),o=u*h;n.push(St(i,o))}const s=[],a=[0,0],r=[0,0];for(let c=0;c<n.length;c++){const{rings:i,spatialReference:l}=n[c];let u=0;for(let h=0;h<i.length;h++){const o=i[h];T(a,o[0],l),T(r,o[o.length-1],l);let d=r[0]*a[1]-a[0]*r[1];for(let M=0;M<o.length-1;M++)T(a,o[M+1],l),T(r,o[M],l),d+=r[0]*a[1]-a[0]*r[1];u+=d}u=st(u,"square-meters",e),s.push(u/-2)}return s}function kt(t,e="meters"){if(!t)throw new P("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(t.some(s=>!F(s.spatialReference)))throw new P("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let s=0;s<t.length;s++){const a=t[s],{spatialReference:r}=a,c=a.type==="polyline"?a.paths:a.rings;let i=0;for(let l=0;l<c.length;l++){const u=c[l];let h=0;for(let o=1;o<u.length;o++){const d=u[o-1][0],M=u[o][0],y=u[o-1][1],m=u[o][1];if(y!==m||d!==M){const p=new Y;_(p,[d,y],[M,m],r),h+=p.distance}}i+=h}i=st(i,"meters",e),n.push(i)}return n}function St(t,e){if(t.type!=="polyline"&&t.type!=="polygon")throw new P("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=t;if(!F(n))throw new P("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const s=t.type==="polyline"?t.paths:t.rings,a=[],r=[0,0],c=new Y;for(const i of s){const l=[];a.push(l),l.push([i[0][0],i[0][1]]);let u,h,o=i[0][0],d=i[0][1];for(let M=0;M<i.length-1;M++){if(u=i[M+1][0],h=i[M+1][1],o===u&&d===h)continue;const y=[o,d];_(c,[o,d],[u,h],n);const{azimuth:m,distance:p}=c,w=p/e;if(w>1){for(let g=1;g<=w-1;g++)B(r,y,m,g*e,n),l.push(r.slice(0));B(r,y,m,(p+Math.floor(w-1)*e)/2,n),l.push(r.slice(0))}B(r,y,m,p,n),l.push(r.slice(0)),o=r[0],d=r[1]}}return t.type==="polyline"?new dt({paths:a,spatialReference:n}):new Mt({rings:a,spatialReference:n})}class Y{constructor(e=0,n=void 0,s=void 0){this.distance=e,this.azimuth=n,this.reverseAzimuth=s}}function B(t,e,n,s,a){const r=e[0],c=e[1],i=r*v,l=c*v,u=(n??0)*v,{a:h,b:o,f:d}=J(a),M=Math.sin(u),y=Math.cos(u),m=(1-d)*Math.tan(l),p=1/Math.sqrt(1+m*m),w=m*p,g=Math.atan2(m,y),C=p*M,S=C*C,j=1-S,f=j*(h*h-o*o)/(o*o),x=1+f/16384*(4096+f*(f*(320-175*f)-768)),A=f/1024*(256+f*(f*(74-47*f)-128));let R,q,$,N,k=s/(o*x),z=2*Math.PI;for(;Math.abs(k-z)>1e-12;)$=Math.cos(2*g+k),R=Math.sin(k),q=Math.cos(k),N=A*R*($+A/4*(q*(2*$*$-1)-A/6*$*(4*R*R-3)*(4*$*$-3))),z=k,k=s/(o*x)+N;const b=w*R-p*q*y,G=Math.atan2(w*q+p*R*y,(1-d)*Math.sqrt(S+b*b)),L=Math.atan2(R*M,p*q-w*R*y),I=d/16*j*(4+d*(4-3*j)),W=G/v,X=(i+(L-(1-I)*d*C*(k+I*R*($+I*q*(2*$*$-1)))))/v;return t[0]=X,t[1]=W,t}function _(t,e,n,s){const a=e[0]*v,r=e[1]*v,c=n[0]*v,i=n[1]*v,{a:l,b:u,f:h,radius:o}=J(s),d=c-a,M=Math.atan((1-h)*Math.tan(r)),y=Math.atan((1-h)*Math.tan(i)),m=Math.sin(M),p=Math.cos(M),w=Math.sin(y),g=Math.cos(y);let C,S,j,f,x,A,R,q,$,N,k=1e3,z=d;do{if(R=Math.sin(z),q=Math.cos(z),j=Math.sqrt(g*R*(g*R)+(p*w-m*g*q)*(p*w-m*g*q)),j===0)return t.distance=0,t.azimuth=void 0,t.reverseAzimuth=void 0,t;x=m*w+p*g*q,A=Math.atan2(j,x),$=p*g*R/j,S=1-$*$,f=x-2*m*w/S,isNaN(f)&&(f=0),N=h/16*S*(4+h*(4-3*S)),C=z,z=d+(1-N)*h*$*(A+N*j*(f+N*x*(2*f*f-1)))}while(Math.abs(z-C)>1e-12&&--k>0);if(k===0){const X=o,ct=Math.acos(Math.sin(r)*Math.sin(i)+Math.cos(r)*Math.cos(i)*Math.cos(c-a))*X,tt=c-a,lt=Math.sin(tt)*Math.cos(i),ut=Math.cos(r)*Math.sin(i)-Math.sin(r)*Math.cos(i)*Math.cos(tt),ht=Math.atan2(lt,ut);return t.azimuth=ht/v,t.distance=ct,t.reverseAzimuth=void 0,t}const b=S*(l*l-u*u)/(u*u),G=b/1024*(256+b*(b*(74-47*b)-128)),L=u*(1+b/16384*(4096+b*(b*(320-175*b)-768)))*(A-G*j*(f+G/4*(x*(2*f*f-1)-G/6*f*(4*j*j-3)*(4*f*f-3)))),I=Math.atan2(g*Math.sin(z),p*w-m*g*Math.cos(z)),W=Math.atan2(p*Math.sin(z),p*w*Math.cos(z)-m*g);return t.azimuth=I/v,t.distance=L,t.reverseAzimuth=W/v,t}function Ut(t){return F(t)?t:Q(t)?ft.WGS84:null}function Zt(t,e,n,s){n.projectToRenderScreen(t,et),n.projectToRenderScreen(e,nt),wt(s,nt,et),Rt(s,s)}function xt(t,e,n,s,a=Z()){const r=vt(K,t);return r[2]=jt(s,r,e,n)||0,s.renderCoordsHelper.toRenderCoords(r,e,a),a}function Ht(t,e,n,s){return s.type==="2d"?(E.x=t[0],E.y=t[1],E.spatialReference=e,s.toScreen(E)):(xt(t,e,n,s,K),s.state.camera.projectToScreen(K,D),gt(D[0],D[1]))}const E=$t(0,0,0,null),K=Z(),et=at(),nt=at(),D=yt();function Jt(t){return V(t)&&F(t)||Q(t)}function ot(t,e,n,...s){return V(t)&&F(t)?e.apply(void 0,s):Q(t)?n.apply(void 0,s):null}const Lt=1e5;function Wt(t){const{spatialReference:e}=t;return ot(e,Ft,Gt,t)}function Xt(t,e){if(!zt(t.spatialReference,e.spatialReference))return null;const{spatialReference:n}=t;return O[0]=t.x,O[1]=t.y,O[2]=t.hasZ?t.z:0,U[0]=e.x,U[1]=e.y,U[2]=e.hasZ?e.z:0,At(O,U,n)}function At(t,e,n){return ot(n,Nt,Ct,t,e,n)}function Nt(t,e,n){return H(_(Pt,t,e,n).distance,"meters")}function Ct(t,e,n){return H(rt(It(t,e,n),"meters"),"meters")}function Ft(t){return H(kt([t],"meters")[0],"meters")}function Gt(t){return H(rt(t,"meters"),"meters")}function It(t,e,n){return{type:"polyline",spatialReference:n,paths:[[[...t],[...e]]]}}const Pt=new Y,O=Z(),U=Z();export{Ut as A,Zt as a,B as b,Ht as d,Xt as f,Lt as i,_ as j,xt as l,Wt as m,ot as p,Jt as r,At as u,Ot as y,Y as z};
