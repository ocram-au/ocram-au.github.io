import{fw as b,fx as u,fy as M,cU as y,fz as C,fA as I,fB as x,fC as k,fD as O,fE as S,T as h}from"./index-QRcEofMq.js";import N from"./callExpressionWithFeature-D5vIp2S-.js";const P=m=>{if(!m)return[0,0,0,0];const{r:e,g:r,b:s,a:t}=m;return[e,r,s,255*t]};class o{static findApplicableOverrides(e,r,s){if(e&&r){if(e.primitiveName){let t=!1;for(const i of s)if(i.primitiveName===e.primitiveName){t=!0;break}if(!t)for(const i of r)i.primitiveName===e.primitiveName&&s.push(i)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const t of e.effects)o.findApplicableOverrides(t,r,s);if(e.symbolLayers)for(const t of e.symbolLayers)o.findApplicableOverrides(t,r,s);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const t of e.effects)o.findApplicableOverrides(t,r,s);if(e.markerPlacement&&o.findApplicableOverrides(e.markerPlacement,r,s),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const t of e.markerGraphics)o.findApplicableOverrides(t,r,s),o.findApplicableOverrides(t.symbol,r,s)}else e.type==="CIMCharacterMarker"?o.findApplicableOverrides(e.symbol,r,s):e.type==="CIMHatchFill"?o.findApplicableOverrides(e.lineSymbol,r,s):e.type==="CIMPictureMarker"&&o.findApplicableOverrides(e.animatedSymbolProperties,r,s)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&b(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const s=u(e),t=e.primitiveName,i=[];for(const c of r)c.primitiveName===t&&i.push(u(c));return{type:"cim-effect-param",effect:s,overrides:M(i)}}static async resolveSymbolOverrides(e,r,s,t,i,c,a){if(!(e!=null&&e.symbol))return null;let{symbol:n,primitiveOverrides:l}=e;const v=!!l;if(!v&&!t)return n;n=y(n),l=y(l);let d=!0;if(r||(r={attributes:{}},d=!1),v){if(d||(l=l.filter(f=>{var p;return!((p=f.valueExpressionInfo)!=null&&p.expression.includes("$feature"))})),a||(l=l.filter(f=>{var p;return!((p=f.valueExpressionInfo)!=null&&p.expression.includes("$view"))})),l.length>0){const f={spatialReference:s,fields:C(r.attributes),geometryType:i};await o.createRenderExpressions(l,f),o.evaluateOverrides(l,r,i??"esriGeometryPoint",c,a)}o.applyOverrides(n,l)}return t&&o.applyDictionaryTextOverrides(n,r,t,null),n}static async createRenderExpressions(e,r){const s=[];for(const t of e){const i=t.valueExpressionInfo;if(!i||o._expressionToRenderExpression.has(i.expression))continue;const c=I(i.expression,r.spatialReference,r.fields);s.push(c),c.then(a=>o._expressionToRenderExpression.set(i.expression,a))}s.length>0&&await Promise.all(s)}static evaluateOverrides(e,r,s,t,i){const c={$view:{scale:i==null?void 0:i.scale}};for(const a of e){a.value&&typeof a.value=="object"&&x(a.value)&&(a.propertyName==="Color"||a.propertyName==="StrokeColor")&&(a.value=P(a.value));const n=a.valueExpressionInfo;if(!n)continue;const l=o._expressionToRenderExpression.get(n.expression);l&&(a.value=N(l,r,c,s,t))}}static applyDictionaryTextOverrides(e,r,s,t,i="Normal"){if(e!=null&&e.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const c=e.symbolLayers;if(!c)return;for(const a of c)a&&a.type==="CIMVectorMarker"&&o.applyDictionaryTextOverrides(a,r,s,t,e.type==="CIMTextSymbol"?e.textCase:i)}break;case"CIMVectorMarker":{const c=e.markerGraphics;if(!c)return;for(const a of c)a&&o.applyDictionaryTextOverrides(a,r,s,t)}break;case"CIMMarkerGraphic":{const c=e.textString;if(c&&c.includes("[")){const a=k(c,s);e.textString=O(r,a,t,i)}}}}static applyOverrides(e,r,s,t){if(e.primitiveName){for(const i of r)if(i.primitiveName===e.primitiveName){const c=S(i.propertyName);if(t&&t.push({cim:e,nocapPropertyName:c,value:e[c]}),s){let a=!1;for(const n of s)n.primitiveName===e.primitiveName&&(a=!0);a||s.push(i)}i.value!=null&&(e[c]=i.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const i of e.effects)o.applyOverrides(i,r,s,t);if(e.symbolLayers)for(const i of e.symbolLayers)o.applyOverrides(i,r,s,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const i of e.effects)o.applyOverrides(i,r,s,t);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const i of e.markerGraphics)o.applyOverrides(i,r,s,t),o.applyOverrides(i.symbol,r,s,t)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const s of e)s.value!==void 0&&(r+=`${s.primitiveName}${s.propertyName}${JSON.stringify(s.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map(s=>Number(s));if(e==="Color"){const s=new h(r).toRgba();return s[3]*=255,s}return r}}o._expressionToRenderExpression=new Map;export{o as OverrideHelper};
